// Объекты отличаются от примитивов тем, что копируются и сохраняются по ссылке.

/* Примитивные значения, такие как строки, числа, логические значения и т.д. всегда копируются как целое значение. Рассмотрим это на примере примитивного значения - строки. Здесь мы помещаем копию message во phrase: */

let message = 'Hello';
let phrse = message;

/* В результате мы имеем две независимые переменные, каждая из которых хранит строку 'Hello'. */

// Переменная, которой присвоен объект, хранит в себе не сам объект, а его "адрес", другими словами "ссылку" на него.

/* let user = {
    name: 'John'
}; */

/* Объект хранится где-то в памяти, в то время как переменная user хранит лишь ссылку на него. Эту переменную можно сравнить с листом бумаги, на котором написан адрес объекта. */

// При копировании переменной объекта копируется ссылка, но сам объект не дублируется! Например:

let user = {
    name: 'John'
};
let admin = user; // копируется ссылка

/* Теперь у нас есть две переменные, каждая из которых хранит ссылку на один и тот же объект. Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого. */

admin.name = 'Pete';
alert(user.name); // Pete








// СРАВНЕНИЯ ПО ССЫЛКЕ

// Два объекта равны только в том случае, если это один и тот же объект!

/* Например, здесь a и b равны, потомучто они ссылаются на один и тот же объект: */

let a = {};
let b = a;
alert(a == b); // true
alert(a === b);  // true

/* И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты): */

let c = {};
let d = {}; // два независимых объекта

alert( c == d ); // false








// КЛОНИРОВАНИЕ И ОБЪЕДИНЕНИЕ

/* Для клонирования объекта, нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав его на примитивном уровне: */

let user1 = {
    name: 'John',
    age: 30
};

let clone = {}; // создаем пустой объект

/* копируем все свойства user в него */

for (let key in user) {
    clone[key] = user[key];
}

/* теперь clone это полностью независимый объект с тем же содержимым */

clone.name = 'Pete';

// Также мы можем использовать для этого метод Object.assign. Синтаксис:

// Object.assign(dest, [src1, src2, src3...])

/* 
    * Первый аргумент dest - целевой объект
    * Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
    * Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
    * Возвращает объект dest.
*/

// Например, мы можем использовать его для объединения нескольких объектов в один:

let user2 = {
    name: 'Sarah'
};

let permission1 = {
    canView: true
};

let permission2 = {
    canEdit: true
};

/* Копируем все свойства permission1 и permission2 в user: */

Object.assign(user, permission1, permission2);

// теперь user = { name: "John", canView: true, canEdit: true }

/* Если скопированное имя свойства уже существует, оно будет перезаписано: */

let user4 = { name: "John" };

Object.assign(user4, { name: "Pete" });
/* 
alert(user4.name); // теперь user = { name: "Pete" } */

// Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования:

let user5 = {
    name: "John",
    age: 30
  };
  
  let clone2 = Object.assign({}, user5);








// ВЛОЖЕННОЕ КЛОНИРОВАНИЕ

/* До сих пор мы предполагали, что все свойства user примитивныe. Но свойства могут быть и ссылками на другие объекты. Что с ними делать?

Например, есть объект: */

let user6 = {
    name: "John",
    sizes: {
      height: 182,
      width: 50
    }
  };
  
  alert( user6.sizes.height ); // 182