/* Объект — это совокупность связанных данных и/или функциональных возможностей. Обычно состоят из нескольких переменных и функций, которые называются свойства и методы, если они находятся внутри объектов. */

/* Пример объявления объекта: */

/* const person = {};
console.log(typeof(person)); // object */

/* Это пустой объект, поэтому мы не можем с ним ничего сделать. */


/* const person = {
    name: ['Claire', 'Ranndell'],
    age: 27,
    gender: 'female',
    interests: ['history', 'music'],
    bio: function () {
        alert(this.name[0] + ' ' + this.name[1] + ' is' + this.age + ' years old. She likes ' + this.interests[0] + ', ' + this.interests[1] + '.');
    },
    greeting: function () {
        alert('Hi! I\'m ' + this.name[0] + '.');
    }
};
 */
/* Попробуем ввести в консоль несколлько запросов: */

/* person.name[0]; // 'Claire'
person.age; // 27 */

/* Как видите, наш объект содержит некоторые данные, а также несколько методов. У нас же с помощью простого синтаксиса есть доступ к ним. */

/* Итак что здесь происходит? Объект состоит из нескольких элементов, каждый из которых имеет своё название (пример name и age выше), и значение (пример ['Bob', 'Smith'] и 32). Каждая пара название/значение должны быть разделены запятой, а название и значение в каждом случае разделяются двоеточием. Синтаксис всегда следует этому образцу: */

//const objectName = {
//    member1Name: member1Value,
//    member2Name: member2Value,
//    member3Name: member3Value
//  };

/* Значение члена объекта может быть чем угодно — в нашем объекте person есть строка, число, два массива, и две функции. Первые четыре элемента это элементы данных, относящиеся к свойствам объекта. Последние два элемента являются функциями, которые позволяют объекту что-то сделать с элементами данных, и называются методами объекта. */

// Такие объекты называются литералами объекта (object literal) — мы буквально вписали все содержимое объекта для его создания. 

/* Очень часто для создания объекта используется литерал объекта когда вам нужно каким-то образом перенести ряд структурированных, связанных элементов данных, например, отправляя запрос на сервер, для размещения их в базе данных. Отправка одного объекта намного эффективнее, чем отправка нескольких элементов по отдельности, и с ним легче работать чем с массивом, если требуется идентифицировать отдельные элементы по имени. */








// ТОЧЕЧНАЯ ЗАПИСЬ (DOT NOTATION)

/* Выше вы получили доступ к свойствам и методам используя точечную запись (dot notation). Имя объекта (person) действует как пространство имён (namespace) — оно должно быть введено первым, для того чтобы получить доступ ко всему что заключено (encapsulated) внутри объекта. Далее вы пишете точку, затем элемент, к которому хотите получить доступ — это может быть имя простого свойства, элемент массива, или вызов одного из методов объекта, например: */

/* person.age
person.interests[1]
person.bio() */

// Внутренние пространства имен (Sub-namespaces)

/* Можно даже сделать значением элемента объекта другой объект. Например: */

/* name : {
    fisrt: 'Claire',
    second: 'Randell'
} */

const person = {
    name: {
        first: 'Claire',
        second: 'Randell'
    },
    age: 27,
    gender: 'female',
    interests: ['history', 'music'],
    bio: function () {
        alert(this.name[0] + ' ' + this.name[1] + ' is' + this.age + ' years old. She likes ' + this.interests[0] + ', ' + this.interests[1] + '.');
    },
    greeting: function () {
        alert('Hi! I\'m ' + this.name[0] + '.');
    }
};

/* Здесь мы фактически создаём внутреннее пространство имён (sub-namespace). Это звучит сложно, но на самом деле это не так — для доступа к этим элементам вам нужно сделать один дополнительный шаг с ещё одной точкой. Попробуйте в консоли браузера следующее: */

/* person.name.first // Claire
person.name.last // Randell */







// СКОБОЧНАЯ ЗАПИСЬ (BRACKET NOTATION)

/* Существует другой способ получить свойства объекта — использовать скобочную запись (bracket notation). */

/* person['age']
person['name']['first'] */

/* Это выглядит очень похоже на то, как вы получаете элементы массива, и в принципе это так и есть — вместо использования числовых индексов для выбора элемента, вы ассоциируете имя свойства для каждого значения. Ничего удивительного, что эти объекты иногда называют ассоциативными массивами — они сопоставляют строки со значениями так же, как массивы сопоставляют числовые индексы со значениями. */








// ЗАПИСЬ ЭЛЕМЕНТОВ В ОБЪЕКТ

/* До сих пор мы рассматривали только возврат (или получение) элементов объекта — вы так же можете установить (обновить) значение элемента объекта просто объявив элемент, который вы хотите установить (используя точечную или скобочную запись), например: */

person.age = 45;
person['name']['last'] = 'Cratchit';

/* Вы можете не просто обновлять и устанавливать значения свойств и методов объекта, а так же устанавливать совершенно новые элементы. Попробуйте их в консоли JS: */

person['eyes'] = 'hazel';
person.farewell = function() { alert("Bye everybody!"); }

/* person.farewell(); */

/* Одним из полезных аспектов скобочной записи является то, что с её помощью можно динамически задавать не только значения элементов, но и их имена. Предположим, что мы хотим, чтобы пользователи могли хранить пользовательские типы данных, введя имя и значение элемента в два следующих поля? Мы могли бы получить эти значения следующим образом: */

/* let myDataName = nameInput.value;
let myDataValue = nameValue.value; */

/* Затем мы можем добавить имя и значение этого нового элемента в объект person таким образом: */

/* person[myDataName] = myDataValue; */

/* Чтобы проверить это, попробуйте добавить следующие строки в свой код, после закрывающей скобки объекта person : */

let myDataName = 'height';
let myDataValue = '1.75m';
person[myDataName] = myDataValue;

/* Добавление свойства объекта с использованием вышеописанного метода невозможно с использованием точечной записи, которая может принимать только литеральное имя элемента, а не значение переменной указывающее на имя. */










// ЧТО ТАКОЕ THIS?

/* Ключевое слово this, ссылается на текущий объект, внутри которого пишется код — поэтому в нашем случае this равен объекту person. Но почему просто не написать person?  */
/* Когда мы начинаем создавать конструкторы и т.д., this очень полезен — он всегда будет гарантировать, что используется верное значение, когда контекст элемента изменяется (например, два разных экземпляра объекта person могут иметь разные имена, но захотят использовать своё собственное имя при приветствии. */

/* Давайте проиллюстрируем, что мы имеем в виду, с упрощённой парой объектов person : */

const series1 = {
    name: 'Outlander',
    seasons: '5',
    audio: ['russ', 'eng'],
    message: function () {
        alert('You can watch this series with russ. audio');
    }
}

const series2 = {
    name: 'The midnight club',
    seasons: '1',
    audio: 'eng',
    message: function () {
        alert('You can watch this series just with eng. audio');
    }
}